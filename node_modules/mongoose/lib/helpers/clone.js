'use strict';

<<<<<<< HEAD
=======

const cloneRegExp = require('regexp-clone');
>>>>>>> 519770fc49731418f8ee622bc8217bc1810136ed
const Decimal = require('../types/decimal128');
const ObjectId = require('../types/objectid');
const specialProperties = require('./specialProperties');
const isMongooseObject = require('./isMongooseObject');
const getFunctionName = require('./getFunctionName');
const isBsonType = require('./isBsonType');
const isObject = require('./isObject');
const symbols = require('./symbols');
const trustedSymbol = require('./query/trusted').trustedSymbol;
const utils = require('../utils');


/*!
 * Object clone with Mongoose natives support.
 *
 * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.
 *
 * Functions are never cloned.
 *
 * @param {Object} obj the object to clone
 * @param {Object} options
 * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.
 * @return {Object} the cloned object
 * @api private
 */

function clone(obj, options, isArrayChild) {
  if (obj == null) {
    return obj;
  }

  if (Array.isArray(obj)) {
<<<<<<< HEAD
    return cloneArray(utils.isMongooseArray(obj) ? obj.__array : obj, options);
=======
    return cloneArray(obj, options);
>>>>>>> 519770fc49731418f8ee622bc8217bc1810136ed
  }

  if (isMongooseObject(obj)) {
    // Single nested subdocs should apply getters later in `applyGetters()`
    // when calling `toObject()`. See gh-7442, gh-8295
    if (options && options._skipSingleNestedGetters && obj.$isSingleNested) {
      options = Object.assign({}, options, { getters: false });
    }
<<<<<<< HEAD
    const isSingleNested = obj.$isSingleNested;
=======
>>>>>>> 519770fc49731418f8ee622bc8217bc1810136ed

    if (utils.isPOJO(obj) && obj.$__ != null && obj._doc != null) {
      return obj._doc;
    }

<<<<<<< HEAD
    let ret;
    if (options && options.json && typeof obj.toJSON === 'function') {
      ret = obj.toJSON(options);
    } else {
      ret = obj.toObject(options);
    }

    if (options && options.minimize && isSingleNested && Object.keys(ret).length === 0) {
      return undefined;
    }

    return ret;
  }

  const objConstructor = obj.constructor;

  if (objConstructor) {
    switch (getFunctionName(objConstructor)) {
      case 'Object':
        return cloneObject(obj, options, isArrayChild);
      case 'Date':
        return new objConstructor(+obj);
=======
    if (options && options.json && typeof obj.toJSON === 'function') {
      return obj.toJSON(options);
    }
    return obj.toObject(options);
  }

  if (obj.constructor) {
    switch (getFunctionName(obj.constructor)) {
      case 'Object':
        return cloneObject(obj, options, isArrayChild);
      case 'Date':
        return new obj.constructor(+obj);
>>>>>>> 519770fc49731418f8ee622bc8217bc1810136ed
      case 'RegExp':
        return cloneRegExp(obj);
      default:
        // ignore
        break;
    }
  }

  if (obj instanceof ObjectId) {
    return new ObjectId(obj.id);
  }

  if (isBsonType(obj, 'Decimal128')) {
    if (options && options.flattenDecimals) {
      return obj.toJSON();
    }
    return Decimal.fromString(obj.toString());
  }

<<<<<<< HEAD
  // object created with Object.create(null)
  if (!objConstructor && isObject(obj)) {
    return cloneObject(obj, options, isArrayChild);
  }

  if (typeof obj === 'object' && obj[symbols.schemaTypeSymbol]) {
=======
  if (!obj.constructor && isObject(obj)) {
    // object created with Object.create(null)
    return cloneObject(obj, options, isArrayChild);
  }

  if (obj[symbols.schemaTypeSymbol]) {
>>>>>>> 519770fc49731418f8ee622bc8217bc1810136ed
    return obj.clone();
  }

  // If we're cloning this object to go into a MongoDB command,
  // and there's a `toBSON()` function, assume this object will be
  // stored as a primitive in MongoDB and doesn't need to be cloned.
  if (options && options.bson && typeof obj.toBSON === 'function') {
    return obj;
  }

<<<<<<< HEAD
  if (typeof obj.valueOf === 'function') {
=======
  if (obj.valueOf != null) {
>>>>>>> 519770fc49731418f8ee622bc8217bc1810136ed
    return obj.valueOf();
  }

  return cloneObject(obj, options, isArrayChild);
}
module.exports = clone;

/*!
 * ignore
 */

function cloneObject(obj, options, isArrayChild) {
  const minimize = options && options.minimize;
  const ret = {};
  let hasKeys;

<<<<<<< HEAD
  if (trustedSymbol in obj) {
    ret[trustedSymbol] = obj[trustedSymbol];
  }

  let i = 0;
  let key = '';
  const keys = Object.keys(obj);
  const len = keys.length;

  for (i = 0; i < len; ++i) {
    if (specialProperties.has(key = keys[i])) {
=======
  if (obj[trustedSymbol]) {
    ret[trustedSymbol] = obj[trustedSymbol];
  }

  for (const k of Object.keys(obj)) {
    if (specialProperties.has(k)) {
>>>>>>> 519770fc49731418f8ee622bc8217bc1810136ed
      continue;
    }

    // Don't pass `isArrayChild` down
<<<<<<< HEAD
    const val = clone(obj[key], options, false);

    if (minimize === false && typeof val === 'undefined') {
      delete ret[key];
    } else if (minimize !== true || (typeof val !== 'undefined')) {
      hasKeys || (hasKeys = true);
      ret[key] = val;
=======
    const val = clone(obj[k], options);

    if (!minimize || (typeof val !== 'undefined')) {
      if (minimize === false && typeof val === 'undefined') {
        delete ret[k];
      } else {
        hasKeys || (hasKeys = true);
        ret[k] = val;
      }
>>>>>>> 519770fc49731418f8ee622bc8217bc1810136ed
    }
  }

  return minimize && !isArrayChild ? hasKeys && ret : ret;
}

function cloneArray(arr, options) {
<<<<<<< HEAD
  let i = 0;
  const len = arr.length;
  const ret = new Array(len);
  for (i = 0; i < len; ++i) {
    ret[i] = clone(arr[i], options, true);
  }

  return ret;
}

function cloneRegExp(regexp) {
  const ret = new RegExp(regexp.source, regexp.flags);

  if (ret.lastIndex !== regexp.lastIndex) {
    ret.lastIndex = regexp.lastIndex;
  }
  return ret;
}
=======
  const ret = [];

  for (const item of arr) {
    ret.push(clone(item, options, true));
  }

  return ret;
}
>>>>>>> 519770fc49731418f8ee622bc8217bc1810136ed
